import 'dotenv/config';
import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import { createClient } from 'redis';
import { createAdapter } from '@socket.io/redis-adapter';

const PORT = process.env.PORT || 3001;
const REDIS_URL = process.env.REDIS_URL || 'redis://redis-realtime:6379';
const SOCKET_PATH = process.env.SOCKET_PATH || '/socket.io';

const app = express();
const server = http.createServer(app);

// Socket.IO: фиксируем path и работаем только по websocket
const io = new Server(server, {
    path: SOCKET_PATH,
    transports: ['websocket'],
    cors: {
        // same-origin: Traefik отдаёт фронт и сокеты с одного домена,
        // поэтому допускаем origin=true (или конкретный домен при желании)
        origin: true,
        credentials: true,
    },
});

// Redis adapter (scale-out, несколько инстансов сокет-сервера)
const pub = createClient({ url: REDIS_URL });
const sub = pub.duplicate();
await pub.connect();
await sub.connect();
io.adapter(createAdapter(pub, sub));

// Health-check/инфо
app.get('/health', (_req, res) => res.status(200).json({ ok: true }));

io.on('connection', (socket) => {
    // join/leave — чтобы клиент попадал в персональную комнату
    socket.on('join', ({ room }) => {
        if (room) socket.join(room);
    });

    socket.on('leave', ({ room }) => {
        if (room) socket.leave(room);
    });

    // (опционально) Если хотите принимать от клиента свои события:
    // socket.on('typing', (payload) => {
    //   const { clientId, isTyping } = payload || {};
    //   if (clientId) io.to(`client-${clientId}`).emit('typing', { clientId, isTyping });
    // });
});

// Подписка на сообщения из Redis (каналы вида chat.client.<id>)
await sub.pSubscribe('chat.client.*', (message, channel) => {
    try {
        const payload = JSON.parse(message);
        const clientId = (payload?.clientId || '').toString();
        if (!clientId) return;

        // Отдаём событие строго в комнату клиента
        io.to(`client-${clientId}`).emit('new_message', payload);
    } catch (e) {
        // no-op
    }
});

server.listen(PORT, () => {
    console.log(`[socket-server] Up on :${PORT} (path=${SOCKET_PATH})`);
});