// assets/chat-center/hooks/useSocket.ts
import { useEffect, useRef, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

export type SocketMessage = {
    id?: string;
    clientId: string;
    text: string;
    direction: 'in' | 'out';
    createdAt?: string;
    timestamp?: string;
};

type UseSocketOptions = {
    clientId: string;
    onMessage: (msg: SocketMessage) => void;
    onConnect?: () => void;
    onDisconnect?: (reason?: string) => void;
    /**
     * Менять не нужно, оставляем /socket.io
     * Если когда-то потребуется другой путь — можно передать тут.
     */
    path?: string; // default '/socket.io'
};

/**
 * Простой хук для Socket.IO:
 * - same-origin (URL не указываем, работаем с тем же доменом)
 * - фиксированный path '/socket.io'
 * - только websocket (стабильно за HTTPS/прокси)
 * - join/leave комнаты клиента (имя: "client-<id>")
 */
export function useSocket({
                              clientId,
                              onMessage,
                              onConnect,
                              onDisconnect,
                              path = '/socket.io',
                          }: UseSocketOptions) {
    const socketRef = useRef<Socket | null>(null);

    const emit = useCallback((event: string, payload?: unknown) => {
        socketRef.current?.emit(event, payload);
    }, []);

    useEffect(() => {
        if (!clientId) return;

        const socket = io({
            path,
            transports: ['websocket'],
            withCredentials: true,
            autoConnect: true,
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 500,
            reconnectionDelayMax: 5000,
        });

        socketRef.current = socket;

        const handleConnect = () => onConnect?.();
        const handleDisconnect = (reason: string) => onDisconnect?.(reason);
        socket.on('connect', handleConnect);
        socket.on('disconnect', handleDisconnect);

        // Комната клиента — должна совпадать с серверной логикой
        const room = `client-${clientId}`;

        const handleNewMessage = (payload: SocketMessage) => {
            // подстраховка на случай, если сервер шлёт широковещательно
            if (!payload?.clientId || payload.clientId.toString() !== clientId.toString()) return;
            onMessage(payload);
        };

        // присоединяемся к комнате и вешаем слушатель
        socket.emit('join', { room });
        socket.on('new_message', handleNewMessage);

        return () => {
            try {
                socket.emit('leave', { room });
            } finally {
                socket.off('new_message', handleNewMessage);
                socket.off('connect', handleConnect);
                socket.off('disconnect', handleDisconnect);
                socket.disconnect();
                socketRef.current = null;
            }
        };
    }, [clientId, onMessage, onConnect, onDisconnect, path]);

    return { emit, socket: socketRef.current };
}
